import math
from typing import List, Optional, Tuple, Union

import torch
import torch.nn.functional as F

from torch_spline_interpolation_1_0_0 import *
import numpy as np
import gc
from collections import OrderedDict

import warnings

"""
All based on https://github.com/gwpy/gwpy/blob/v3.0.8/gwpy/signal/qtransform.py
"""

#-------------------------------------------------------------------------------------------------------------
def _centered_pad_or_crop(X: torch.Tensor, M: int) -> torch.Tensor:
    """Helper for ideal band-pass filtering via crop/pad in FFT domain."""
    N = X.shape[-1]
    if M == N:
        return X
    # Use F.fftshift, assuming `import torch.nn.functional as F`
    Xs = torch.fft.fftshift(X, dim=-1)
    if M > N:
        pad_left = (M - N) // 2
        pad_right = M - N - pad_left
        Y = F.pad(Xs, (pad_left, pad_right))
    else:
        start = (N - M) // 2
        end = start + M
        Y = Xs[..., start:end]
    return torch.fft.ifftshift(Y, dim=-1)
#-------------------------------------------------------------------------------------------------------


# ============================
# External Window Functions
# ============================

def planck_taper_window_range(N: int, epsilon: float, x_min: float = -1, x_max: float = 1, device: str = 'cpu') -> torch.Tensor:
    """
    Constructs a Planck-taper window defined over an arbitrary range [x_min, x_max].
    Internally, it maps the coordinate linearly to the canonical range [-1,1] and then applies
    your provided Planck-taper formula.
    
    Args:
        N (int): Window length (number of samples).
        epsilon (float): Taper fraction (0 < epsilon < 0.5).
        x_min (float): Minimum value of the input coordinate.
        x_max (float): Maximum value of the input coordinate.
        device (str): Device.
        
    Returns:
        Tensor: A 1D tensor of shape [N] representing the Planck-taper window.
    """
    # Create coordinate x in [x_min, x_max]
    x = torch.linspace(x_min, x_max, steps=N, device=device, dtype=torch.float32)
    # Map x linearly to the canonical domain [-1,1]
    x_canonical = 2 * (x - x_min) / (x_max - x_min) - 1
    # Map to y in [0,1]
    y = (x_canonical + 1) / 2
    w = torch.ones(N, device=device, dtype=torch.float32)
    # Rising edge: 0 < y < epsilon
    mask_rise = (y > 0) & (y < epsilon)
    if mask_rise.any():
        Z_plus = 2 * epsilon * (1 / (1 + 2 * y[mask_rise] - 1) + 1 / (1 - 2 * epsilon + 2 * y[mask_rise] - 1))
        w[mask_rise] = 1.0 / (torch.exp(Z_plus) + 1.0)
    # Flat region: epsilon <= y <= 1 - epsilon
    mask_flat = (y >= epsilon) & (y <= 1 - epsilon)
    w[mask_flat] = 1.0
    # Falling edge: 1 - epsilon < y < 1
    mask_fall = (y > (1 - epsilon)) & (y < 1)
    if mask_fall.any():
        Z_minus = 2 * epsilon * (1 / (1 - 2 * y[mask_fall] + 1) + 1 / (1 - 2 * epsilon - 2 * y[mask_fall] + 1))
        w[mask_fall] = 1.0 / (torch.exp(Z_minus) + 1.0)
    # Endpoints set to 0
    w[0] = 0.0
    w[-1] = 0.0
    return w

def kaiser_window_range(L: int, beta: float = 8.6, x_min: float = -1, x_max: float = 1, device: str = 'cpu') -> torch.Tensor:
    """
    Returns a Kaiser window of length L defined over an arbitrary range [x_min, x_max].
    The window values are generated by torch.kaiser_window (which is independent of the coordinate),
    so the coordinate mapping is handled externally.
    
    Args:
        L (int): Window length.
        beta (float): Kaiser beta parameter.
        x_min (float): Minimum coordinate value.
        x_max (float): Maximum coordinate value.
        device (str): Device.
    
    Returns:
        Tensor: A 1D tensor of shape [L] representing the Kaiser window.
    """
    return torch.kaiser_window(L, beta=beta, periodic=False, device=device)

def tukey_window(window_length, alpha=0.05):
    """Generates a Tukey window."""
    if alpha < 0 or alpha > 1:
        raise ValueError("Alpha must be between 0 and 1")
    window = torch.ones(window_length)
    if alpha == 0:
        return window
    ramp = int(alpha * window_length / 2)
    if ramp == 0:
        return window
    w = torch.linspace(0, 1, ramp)
    cosine = 0.5 * (1 + torch.cos(torch.pi * (w - 1)))
    window[:ramp] = cosine
    window[-ramp:] = cosine.flip(0)
    return window

def bisquare_window(L: int, device: str = 'cpu') -> torch.Tensor:
    """
    Compute the bisquare window defined as:
      w(x) = (1 - x^2)^2, with x linearly spaced from -1 to 1.
    """
    x = torch.linspace(-1, 1, steps=L, device=device, dtype=torch.float32)
    return (1 - x**2)**2


def hann_window(L: int, device: str = "cpu") -> torch.Tensor:
    """
    Hann window.
    """
    n = torch.arange(L, device=device, dtype=torch.float32)
    w = 0.5 * (1 - torch.cos(2 * math.pi * n / (L - 1)))
    return w

                  
# ============================
# QTile Class
# ============================
class QTile(torch.nn.Module):
    """
    Compute the row of Q-tiles for a single Q value and a single
    frequency for a batch of multi-channel frequency series data.
    Invertible version with windows defined over full frequency series.
    """

    def __init__(
        self,
        q: float,
        frequency: float,
        duration: float,
        sample_rate: float,
        mismatch: float,
        logf: bool = False, # log spaced frequecies
        #energy_mode: bool = True, #return energy (True) or amplitude (False) of the spectrogram
        #phase_mode: bool = False, #return also the phase of the spectrogram
        window_param: Optional[Union[str, torch.Tensor]] = None, # window type ('kaiser', 'hann', 'bisqaure','tukey','planck-taper')
        tau: float = 1/2,   # parameter for planck-taper and tukey window function 
        beta: float = 8.6,  # parameter for kaiser window function 
        eps: float = 1e-5,  # small epsilon for padded values
        max_window_size = None # maximum width of window function
    ):
        super().__init__()
        self.q = q
        self.frequency = frequency
        self.duration = duration
        self.sample_rate = sample_rate
        self.mismatch = mismatch
        self.logf = logf
        #self.energy_mode = energy_mode
        #self.phase_mode = phase_mode
        self.window_param = window_param
        self.tau = tau
        self.beta = beta
        self.eps = eps
        self.max_window_size=max_window_size

        self.qprime = self.q / (11 ** 0.5)
        self.deltam = torch.tensor(2 * (self.mismatch / 3.0) ** 0.5)

        self.windowsize = 2 * int(self.frequency / self.qprime * self.duration) + 1
        #print('-----------------------------')
        if self.max_window_size:
            #print(f'{self.windowsize=} ; {self.max_window_size=}')
            self.windowsize = min(self.windowsize, self.max_window_size)
            
        self.pad_len = (self.duration*self.sample_rate)//2 +1 - self.windowsize
        self.pad_left = int((self.pad_len) // 2)
        self.pad_right = int((self.pad_len + 1) // 2)  

        self.register_buffer("window", self.get_window())
        self.register_buffer("full_window", self.get_full_window())
        
        #print(self.frequency,self.windowsize,self.window.shape,self.full_window.shape)
    
    def compute_window_energy(self, window):
        #Normalize by imposing Parseval condition: sum |w[t]|^2 dt = (1/N) * sum |W[f]|^2 = 1
        return torch.sum(window**2).item()/self.duration

    def get_window(self):
        #SUPPORTED WINDOWS
        
        # Bisquare (gwpy-like)
        if self.window_param is None:
            window = bisquare_window(self.windowsize)
            window[0]+=self.eps
            window[-1]+=self.eps
        
        # Custom window (user input)    
        elif isinstance(self.window_param, torch.Tensor):
            w = self.window_param.flatten()
            if w.shape[0] != self.windowsize:
                w = F.interpolate(w[None, None], size=self.windowsize, mode="linear", align_corners=False).squeeze()
                
        #Hann window
        elif self.window_param.lower() == "hann":
            window= hann_window(self.windowsize)
            window[0]+=self.eps
            window[-1]+=self.eps
            
        #Tukey window
        elif self.window_param.lower() == "tukey":
            window = tukey_window(self.windowsize, alpha=self.tau)

        #Planck-taper window
        elif self.window_param.lower() == "planck-taper":
            window = planck_taper_window_range(self.windowsize, epsilon=self.tau, x_min=-1, x_max=1)

        #Kaiser window
        elif self.window_param.lower() == "kaiser":
            window = kaiser_window_range(self.windowsize, beta=self.beta, x_min=-1, x_max=1)
            
        else:
            raise ValueError(f"Unsupported window_param: {self.window_param}")
        
        return window
    
    def get_full_window(self):
        
        # Pad window to full length with small epsilon and shift to center frequency
        full = F.pad(self.window.unsqueeze(0).unsqueeze(0), (self.pad_left, self.pad_right), value=self.eps)

        #Center window on central frequency
        self.shift = int(self.frequency * self.duration)
        #full_w= torch.roll(full, shifts=self.shift- (self.windowsize // 2 +self.pad_right))
        full_w = torch.roll(full, shifts=self.shift - (self.pad_left + self.windowsize // 2))
        
        #Normalize window    
        wen=self.compute_window_energy(full_w)
        norm = (wen) ** -0.5 
        full_w *= norm
        return full_w
        

    def forward(
        self, 
        fseries: torch.Tensor, 
        polar_mode: bool = True, 
        energy_mode: bool = True, 
        phase_mode: bool = True, 
        complex_mode: bool = False,
        num_time: Optional[int] = None, # Target number of time samples
        am_mode: bool = True             # True for baseband (amplitude), False for remodulated AM signal
    ):
        while len(fseries.shape) < 3:
            fseries = fseries[None]
        
        # Step 1: Bandpass filtering in frequency domain
        wenergy = fseries * self.full_window.to(fseries.device)
        T_in = wenergy.shape[-1]

        # If num_time is not specified, compute full resolution tile (original behavior)
        if num_time is None:
            tdenergy = torch.fft.ifft(wenergy, norm='ortho')
            tdenergy *= (self.sample_rate)**0.5 
        
        # If num_time is specified, perform efficient downsampling
        else:
            T_out = num_time
            # Step 2: Demodulate by shifting to baseband in frequency domain
            wenergy_baseband = torch.roll(wenergy, shifts=-self.shift, dims=-1)
            
            # Step 3: Low-pass filter by cropping the spectrum
            wenergy_baseband_cropped = _centered_pad_or_crop(wenergy_baseband, T_out)
            
            # Step 4: Perform small IFFT to get downsampled baseband signal
            tdenergy_baseband = torch.fft.ifft(wenergy_baseband_cropped, norm='ortho')
            
            # Apply amplitude correction for energy conservation
            tdenergy_baseband *= math.sqrt(T_out / T_in)
            
            if am_mode:
                # We want the baseband signal (the envelope)
                tdenergy = tdenergy_baseband * (self.sample_rate)**0.5
            else:
                # Step 5 (Optional): Remodulate to get AM signal
                # Create time vector for the downsampled signal
                t = torch.linspace(0, self.duration, T_out, device=fseries.device, dtype=torch.float32)
                
                # Create rotation phasor
                phase = 2 * math.pi * self.frequency * t.view(1, 1, -1)
                rot = torch.polar(torch.ones_like(phase), phase)
                
                # Apply remodulation
                tdenergy = tdenergy_baseband * rot * (self.sample_rate)**0.5

        # The rest of the function remains the same, converting the complex `tdenergy`
        # to the desired output format (polar, complex, or real/imag)
        if polar_mode:
            if energy_mode:
                energy = tdenergy.real**2 + tdenergy.imag**2
            else:
                energy = torch.sqrt(tdenergy.real**2 + tdenergy.imag**2)
    
            phase = None
            if phase_mode:
                phase = torch.atan2(tdenergy.imag, tdenergy.real)
                return torch.stack([energy, phase],dim=2)
                
            return energy.unsqueeze(2)
        
        elif complex_mode:
            return tdenergy
        else:
            return torch.stack([tdenergy.real,tdenergy.imag], dim=2)

    
        

    def invert(self, tile, polar_mode: bool = True, energy_mode: bool = True, phase_mode: bool = True, complex_mode: bool = False):
        # Extract amplitude and phase from the tile
        
        if polar_mode:
            amplitude = torch.sqrt(tile[:, :, 0]) if energy_mode else tile[:, :, 0]
            
            if not phase_mode:
                print(f"\033[93m[Warning]\033[0m Qtile.invert: phase_mode is False, assuming all 0 phase.")

            amplitude /= (self.sample_rate)**0.5
            
            if phase_mode:
                phase = tile[:, :, 1]
            else:
                phase = torch.zeros_like(amplitude)
                
            tdenergy = amplitude * torch.exp(1j * phase)   
            
        elif complex_mode:
            tdenergy= tile/(self.sample_rate)**0.5
        else:
            tdenergy= torch.complex(tile[:,:,0,:],tile[:,:,1,:])/ (self.sample_rate)**0.5
        
        # FFT back to frequency domain
        wenergy = torch.fft.fft(tdenergy, norm= 'ortho')

        # Divide by full_window to recover original fseries
        fseries = wenergy / self.full_window
        
        return fseries
        
##########################################################################
# Single Q Qtransform Class
##########################################################################

class SingleQTransform(torch.nn.Module):
    """
    Compute the Q-transform for a single Q value for a batch of
    multi-channel time series data. Input data should have
    three dimensions or fewer.

    Args:
        duration:
            Length of the time series data in seconds
        sample_rate:
            Sample rate of the data in Hz
        spectrogram_shape:
            The shape of the interpolated spectrogram, specified as
            `(num_f_bins, num_t_bins)`. Because the
            frequency spacing of the Q-tiles is in log-space, the frequency
            interpolation is log-spaced as well.
        q:
            The Q value to use for the Q transform
        frange:
            The lower and upper frequency limit to consider for
            the transform. If unspecified, default values will
            be chosen based on q, sample_rate, and duration
        mismatch:
            The maximum fractional mismatch between neighboring tiles
    """

    def __init__(
        self,
        duration: float,
        sample_rate: float,
        q: float = 12,
        frange: List[float] = [0, torch.inf],
        mismatch: float = 0.2,
        num_freq: int = 0,
        logf: bool = False,
        window_param: Optional[Union[str, torch.Tensor]] = None,
        tau: float = 1/2,
        beta: float = 8.6,
        max_window_size = False
        
    ):
        super().__init__()
        self.q = q
        self.sample_rate = sample_rate
        self.frange = frange
        self.duration = duration
        self.mismatch = mismatch
        self.logf= logf
        self.window_param = window_param
        self.tau = tau
        self.beta = beta
        self.num_freq=num_freq
        
        
        qprime = self.q / 11 ** (1 / 2.0)
        if self.frange[0] <= 0:  # set non-zero lower frequency
            self.frange[0] = 50 * self.q / (2 * torch.pi * duration)
        if math.isinf(self.frange[1]):  # set non-infinite upper frequency
            self.frange[1] = sample_rate / 2 / (1 + 1 / qprime)
        self.freqs = self.get_freqs()
        
        if max_window_size:
            #print(f'{max_window_size=}')
            self.max_window_size =self.get_max_window_size(max_window_size)
        else:
            self.max_window_size = None
        
        self.qtile_transforms = torch.nn.ModuleList(
            [
                QTile(
                self.q, freq, self.duration, sample_rate, self.mismatch,
                self.logf,window_param=self.window_param,tau=self.tau,beta=self.beta,max_window_size=self.max_window_size
            )
                for freq in self.freqs
            ]
        )
        self.qtiles = None
        self.phase_qtiles = None  

    def get_freqs(self):
        """
        Calculate the frequencies that will be used in this transform.
        For each frequency, a `QTile` is created.
        """
        minf, maxf = self.frange

        # manually set log spaced frequencies given the desired number of tiles
        if self.num_freq:
            if self.logf:
                freqs = torch.tensor(np.geomspace(minf, maxf, self.num_freq))
            else:
                freqs=torch.linspace(minf,maxf,self.num_freq)
            #print(f'{freqs=}')
        # use gwpy mismatch method instead
        else:
            fcum_mismatch = (
                math.log(maxf / minf) * (2 + self.q**2) ** (1 / 2.0) / 2.0
            )
            deltam = 2 * (self.mismatch / 3.0) ** (1 / 2.0)
            nfreq = int(max(1, math.ceil(fcum_mismatch / deltam)))
            fstep = fcum_mismatch / nfreq
            fstepmin = 1 / self.duration
    
            freq_base = math.exp(2 / ((2 + self.q**2) ** (1 / 2.0)) * fstep)
            freqs = torch.Tensor([freq_base ** (i + 0.5) for i in range(nfreq)])
            freqs = (minf * freqs // fstepmin) * fstepmin
        return torch.unique(freqs)
        
    def get_max_window_size(self, max_w_s: Optional[Union[int, str]]):
        """
        Determines the final max_window_size based on user input.
        """
        # Case 1: No cap provided (pure CQT)
        if max_w_s is None:
            print("[Info] No max_window_size cap applied. Using pure CQT scaling.")
            return None

        # Case 2: User provides a specific integer value
        if isinstance(max_w_s, (int, float)):
            max_size = int(max_w_s)
            print(f"[Info] Using user-defined max_window_size cap: {max_size}")
            
            # --- ADD WARNING ---
            # Calculate the principled minimum size for comparison
            if len(self.freqs) > 1:
                freq_spacings = torch.diff(self.freqs)
                max_spacing_hz = torch.max(freq_spacings)
                principled_min_size = (math.ceil(self.duration * max_spacing_hz.item())//2)*2+1
                if max_size < principled_min_size:
                    print(f"[Warning] User-defined cap ({max_size}) is smaller than the "
                          f"principled minimum ({principled_min_size}) required to guarantee "
                          f"no frequency gaps. This may affect invertibility.")
            return max_size
            
        # Case 3: User requests principled calculation
        if isinstance(max_w_s, str) and max_w_s.lower() == 'auto':
            if len(self.freqs) > 1:
                freq_spacings = torch.diff(self.freqs)
                max_spacing_hz = torch.max(freq_spacings)
                max_size = (math.ceil(self.duration * max_spacing_hz.item())//2)*2+1
                print(f"[Info] Using auto-calculated principled max_window_size: {max_size}")
                return max_size
            else:
                # If there's only one frequency, this concept doesn't apply.
                print("[Info] Only one frequency bin; no max_window_size cap is needed.")
                return None
        
        raise ValueError(f"Invalid input for max_window_size. Must be None, an integer, or 'auto'. Got: {max_w_s}")

    def get_max_energy(
        self, fsearch_range: List[float] = None, dimension: str = "both"
    ):
        """
        Gets the maximum energy value among the QTiles. The maximum can
        be computed across all batches and channels, across all channels,
        across all batches, or individually for each channel/batch
        combination. This could be useful for allowing the use of different
        Q values for different channels and batches, but the slicing would
        be slow, so this isn't used yet.

        Optionally, a pair of frequency values can be specified for
        `fsearch_range` to restrict the frequencies in which the maximum
        energy value is sought.
        """
        allowed_dimensions = ["both", "neither", "channel", "batch"]
        if dimension not in allowed_dimensions:
            raise ValueError(f"Dimension must be one of {allowed_dimensions}")

        if self.qtiles is None:
            raise RuntimeError(
                "Q-tiles must first be computed with .compute_qtiles()"
            )

        if fsearch_range is not None:
            start = min(torch.argwhere(self.freqs > fsearch_range[0]))
            stop = min(torch.argwhere(self.freqs > fsearch_range[1]))
            qtiles = self.qtiles[start:stop]
        else:
            qtiles = self.qtiles

        if dimension == "both":
            return max([torch.max(qtile) for qtile in qtiles])

        max_across_t = [torch.max(qtile, dim=-1).values for qtile in qtiles]
        max_across_t = torch.stack(max_across_t, dim=-1)
        max_across_ft = torch.max(max_across_t, dim=-1).values

        if dimension == "neither":
            return max_across_ft
        if dimension == "channel":
            return torch.max(max_across_ft, dim=-2).values
        if dimension == "batch":
            return torch.max(max_across_ft, dim=-1).values


    def compute_qtiles(
        self, 
        X: torch.Tensor, 
        polar_mode: bool = True, 
        energy_mode: bool = True, 
        phase_mode: bool = True, 
        complex_mode: bool = False,
        num_time: Optional[int] = None, 
        am_mode: bool = True           
    ):
        """
        Take the FFT of the input timeseries and calculate the transform
        for each `QTile`
        """
        X_fft = torch.fft.rfft(X, norm='ortho')
        
        # Pass the new arguments to each QTile's forward method
        self.qtiles = [
            qtile(
                X_fft, polar_mode, energy_mode, phase_mode, complex_mode,
                num_time=num_time, am_mode=am_mode
            ) 
            for qtile in self.qtile_transforms
        ]
        
#------------------------------------------------------------------------------------------------------------------------------------
    
    ### SPLINE INTERPOLATION ###
    def interpolate(self, Z, num_f_bins, num_t_bins, polar_mode: bool = True, phase_mode: bool = True, complex_mode: bool = False):
        
        '''
            WARNING: 
            - Spline inteprolation is not invertible, for invertible down/upsampling use XXX
            - Interpolation of phase is not really meaningfull because of Aliasing. It is particularly bad for polar_mode=False. 
              For a more sound phase interpolation use: XXX
                    
        '''
        
        device= Z.device

        #Devide input into Re/IM or Amp/Phase depending on modes
        if (not polar_mode): 
            if complex_mode:
                A = Z.real
                P = Z.imag
            else:
                A = Z[:,:,0,:,:]
                P = Z[:,:,1,:,:]
        else:
            A = Z[:,:,0,:,:]
            if phase_mode:
                P = Z[:,:,1,:,:]
                
        # Build grids for natural bicubic spline
        xin = torch.linspace(0.0,self.duration, steps=Z.shape[-1])
        xout= torch.linspace(0.0,self.duration, steps=num_t_bins)
        
        if self.logf:
            yout = torch.tensor(np.geomspace(
                self.frange[0],
                self.frange[1],
                num=num_f_bins,))
        else:
            yout=torch.linspace(self.frange[0], self.frange[1],num_f_bins)
        
        #define NN for 2d interpolation
        spline_interpolate_2d=SplineInterpolate2D(num_t_bins=num_t_bins, num_f_bins=num_f_bins,logf=self.logf,frange=self.frange).to(device)
        
        #interpolate Qtransform
        resampled=spline_interpolate_2d(A.transpose(-1,-2),xin=xin,xout=xout,yin=self.freqs,yout=yout)    

        # Interpolate phase/imag if required
        if phase_mode or (not polar_mode):  
            
            phase_interp = spline_interpolate_2d(
                P.transpose(-1,-2), xin=xin, xout=xout,
                yin=self.freqs.to(device), yout=yout
            )

            if (not polar_mode) and complex_mode:
                return torch.complex(resampled,phase_interp)
                
            return torch.stack([resampled, phase_interp], dim=2) #.detach().cpu()  

        return resampled #.detach().cpu()
#-------------------------------------------------------------------------------------------------------------
    ### FOURIER INTERPOLATION ###
    def _centered_pad_or_crop(self, X: torch.Tensor, M: int) -> torch.Tensor:
        """Helper for ideal band-pass filtering via crop/pad in FFT domain."""
        N = X.shape[-1]
        if M == N:
            return X
        # Use F.fftshift, assuming `import torch.nn.functional as F`
        Xs = torch.fft.fftshift(X, dim=-1)
        if M > N:
            pad_left = (M - N) // 2
            pad_right = M - N - pad_left
            Y = F.pad(Xs, (pad_left, pad_right))
        else:
            start = (N - M) // 2
            end = start + M
            Y = Xs[..., start:end]
        return torch.fft.ifftshift(Y, dim=-1)

    def _row_mod(self, Zc: torch.Tensor, sign: int) -> torch.Tensor:
        """Helper to apply phase rotation for remodulation (sign=+1) or demodulation (sign=-1)."""
        B, C, n_freqs, T = Zc.shape
        device = Zc.device
        dtype = Zc.real.dtype
        
        step = self.duration / T
        end_point = self.duration #- step
        t = torch.linspace(0, end_point, T, device=device, dtype=dtype)
        
        f = self.freqs.to(device, dtype).view(1, 1, n_freqs, 1)
        phase = 2 * math.pi * f * t.view(1, 1, 1, T)
        rot = torch.polar(torch.ones_like(phase), sign * phase)
        return Zc * rot

    def downsample(self, Z_in, T_out: int, polar_mode: bool, energy_mode: bool, phase_mode: bool, complex_mode: bool, preserve_amplitude=True, remod: bool = False):
        """
        Downsamples the spectrogram using the stable frequency-domain method.
        Handles various input formats by passing mode flags.
        """
        T_in = Z_in.shape[-1]
        if T_in == T_out:
            return Z_in

        # --- 1. Convert any input format to complex tdenergy ---
        if polar_mode:
            amplitude = torch.sqrt(Z_in[:, :, 0]) if energy_mode else Z_in[:, :, 0]
            phase = Z_in[:, :, 1] if phase_mode else torch.zeros_like(amplitude)
            if not phase_mode:
                print(f"\033[93m[Warning]\033[0m phase_mode is False, assuming all 0 phase.")
            Zc_in = torch.polar(amplitude, phase)
        elif complex_mode:
            Zc_in = Z_in
        else: # Real/Imag channels
            Zc_in = torch.complex(Z_in[:, :, 0], Z_in[:, :, 1])
            
        # --- 2. Core resampling logic (operates on complex values) ---
        Zf_in = torch.fft.fft(Zc_in, dim=-1, norm='ortho')
        C_k_ds_list = []
        for k, qt in enumerate(self.qtile_transforms):
            center_freq_bin = qt.shift
            print(f'frequency:{self.freqs[k]}, idx:{k}, shift: {qt.shift}')
            Zf_k = Zf_in[:, :, k, :]
            Zf_k_bb = torch.roll(Zf_k, shifts=-center_freq_bin, dims=-1)
            Zf_k_bb_cropped = self._centered_pad_or_crop(Zf_k_bb, T_out)
            C_k_ds = torch.fft.ifft(Zf_k_bb_cropped, dim=-1, norm='ortho')
            C_k_ds_list.append(C_k_ds)
        C_ds = torch.stack(C_k_ds_list, dim=2)
        
        if preserve_amplitude:
            C_ds *= math.sqrt(T_out / T_in)
            
        if remod==True:
            Zc_out = self._row_mod(C_ds, sign=+1)
        else:
            Zc_out= C_ds 
        
        # --- 3. Convert complex output back to the original format ---
        if polar_mode:
            energy = Zc_out.abs()**2 if energy_mode else Zc_out.abs()
            if phase_mode:
                phase = Zc_out.angle()
                return torch.stack([energy, phase], dim=2)
            return energy.unsqueeze(2)
        elif complex_mode:
            return Zc_out
        else: # Real/Imag channels
            return torch.stack([Zc_out.real, Zc_out.imag], dim=2)

    def upsample(self, Z_coarse, T_in: int, polar_mode: bool, energy_mode: bool, phase_mode: bool, complex_mode: bool, preserve_amplitude=True, demod:bool = False):
        """
        Upsamples the spectrogram by reversing the frequency-domain process.
        """
        T_out = Z_coarse.shape[-1]
        if T_in == T_out:
            return Z_coarse

        if polar_mode:
            amplitude = torch.sqrt(Z_coarse[:, :, 0]) if energy_mode else Z_coarse[:, :, 0]
            phase = Z_coarse[:, :, 1] if phase_mode else torch.zeros_like(amplitude)
            if not phase_mode:
                print(f"\033[93m[Warning]\033[0m phase_mode is False, assuming all 0 phase.")
            Zc_coarse = torch.polar(amplitude, phase)
        elif complex_mode:
            Zc_coarse = Z_coarse
        else: # Real/Imag channels
            Zc_coarse = torch.complex(Z_coarse[:, :, 0], Z_coarse[:, :, 1])
            
        if demod == True:  
            C_ds = self._row_mod(Zc_coarse, sign=-1)
        else:
            C_ds = Zc_coarse
        
        Zf_k_recon_list = []
        for k, qt in enumerate(self.qtile_transforms):
            C_k_ds = C_ds[:, :, k, :]
            Zf_k_bb_cropped = torch.fft.fft(C_k_ds, dim=-1, norm='ortho')
            Zf_k_bb = self._centered_pad_or_crop(Zf_k_bb_cropped, T_in)
            center_freq_bin = qt.shift
            Zf_k_recon = torch.roll(Zf_k_bb, shifts=center_freq_bin, dims=-1)
            Zf_k_recon_list.append(Zf_k_recon)
        
        Zf_recon = torch.stack(Zf_k_recon_list, dim=2)
        Zc_out = torch.fft.ifft(Zf_recon, dim=-1, norm='ortho')
        
        if preserve_amplitude:
            Zc_out *= math.sqrt(T_in / T_out)
    
        if polar_mode:
            energy = Zc_out.abs()**2 if energy_mode else Zc_out.abs()
            if phase_mode:
                phase = Zc_out.angle()
                return torch.stack([energy, phase], dim=2)
            return energy.unsqueeze(2)
        elif complex_mode:
            return Zc_out
        else: # Real/Imag channels
            return torch.stack([Zc_out.real, Zc_out.imag], dim=2)

    def check_aliasing_and_report(self, T_out: int):
        """
        Checks for potential information loss (aliasing) and reports detailed diagnostics,
        taking into account the VQT `max_window_size` if it is set.
        """
        print("\n--- Downsampling Analysis ---")
        qprime = self.q / (11**0.5)
        duration = self.duration
        cqt_sizes = 2 * torch.floor(self.freqs.cpu() / qprime * duration) + 1
        
        max_size = getattr(self, 'max_window_size', None)
        
        if max_size is not None:
            print(f"[Info] VQT mode detected with max_window_size = {max_size}")
            final_sizes = torch.minimum(cqt_sizes, torch.tensor(float(max_size)))
        else:
            print("[Info] Pure CQT mode detected (no window size cap).")
            final_sizes = cqt_sizes
            
        n_bins_required = final_sizes.numpy()
        aliasing_mask = T_out < n_bins_required
        n_bad = int(aliasing_mask.sum())
    
        min_T_out_for_lossless = int(np.max(n_bins_required))
        
        supported_mask = ~aliasing_mask
        max_f_supported = float(self.freqs[supported_mask].max().item()) if supported_mask.any() else 0.0
        
        if n_bad > 0:
            affected_freqs = self.freqs.cpu().numpy()[aliasing_mask]
            print(f"\033[93m[Warning]\033[0m {n_bad}/{len(self.freqs)} frequency rows will be truncated (information loss).")
            print(f"          Your chosen T_out = {T_out} is too small for the windows being used.")
            print(f"          Affected frequencies start from ~{affected_freqs.min():.2f} Hz upwards.")
            print("-" * 20)
            print(f"To be lossless for all frequencies, you MUST use at least T_out = {min_T_out_for_lossless}.")
            print(f"With T_out = {T_out}, the maximum fully supported frequency is ~{max_f_supported:.2f} Hz.")
        else:
            print("[Info] No information loss detected.")
            print(f"       Your chosen T_out = {T_out} is sufficient for lossless resampling.")
            print(f"       (Minimum required T_out for this spectrogram is {min_T_out_for_lossless}).")
        
        print("---------------------------\n")
        return torch.from_numpy(aliasing_mask)
#-------------------------------------------------------------------------------------------------------------
    
    def forward(
        self,
        X: torch.Tensor,
        
        #spectroram parameters
        normalize: bool = False,
        polar_mode: bool = True,
        energy_mode: bool = True,
        phase_mode: bool = True,
        complex_mode: bool = False,
        
        #interpolation parameters
        interp_mode : str = None, #other modes is 'spline'
        num_time : int = None,
        spectrogram_shape: Optional[Tuple[int, int]] = None,
        am_mode: bool = True,
        

    ):
        """
        Compute the Q-tiles and interpolate

        Args:
            X:
                Time series of data. Should have the duration and sample rate
                used to initialize this object. Expected input shape is
                `(B, C, T)`, where T is the number of samples, C is the number
                of channels, and B is the number of batches. If less than
                three-dimensional, axes will be added during Q-tile
                computation.
                
            normalize:
                normalize input with repsect to max for nicer visualization if data is not already normalized or whitened. 
                Note the THIS BREAKS INVERTIBILITY, for VISUALIZATION ONLY!
                
            spectrogram_shape:
                The shape of the interpolated spectrogram, specified as
                `(num_f_bins, num_t_bins)`. Because the
                frequency spacing of the Q-tiles is in log-space, the frequency
                interpolation is log-spaced as well. If not given, the shape
                used to initialize the transform will be used.

        Returns:
            The interpolated Q-transform for the batch of data. Output will
            have one more dimension than the input
        """
        if normalize:
            X_norm=X.clone()
            X_norm/=torch.max(X_norm,dim=-1).values.unsqueeze(-1)
            X=X_norm
            
        # Path 1: Efficiently compute downsampled transform directly
        if num_time is not None:
            
            # Check for aliasing before computation
            T_in = (int(self.sample_rate * self.duration) // 2) + 1
            if num_time < T_in:
                 self.check_aliasing_and_report(num_time)

            self.compute_qtiles(
                X, polar_mode, energy_mode, phase_mode, complex_mode,
                num_time=num_time, am_mode=am_mode
            )

        # Path 2: Compute full-res tiles for spline interpolation or raw output
        else:
            self.compute_qtiles(
                X, polar_mode, energy_mode, phase_mode, complex_mode,
                num_time=None, am_mode=am_mode # Ensures full resolution
            )
        
        # --- Stack the computed tiles ---
        if not polar_mode and complex_mode:
            stacking_dim = 2 # B, C, F, T
        else:
            stacking_dim = 3 # B, C, P, F, T
        qtiles_stacked = torch.stack(self.qtiles, dim=stacking_dim)

        # --- Handle post-processing (spline interpolation) ---
        if interp_mode and interp_mode.lower() == 'spline':
            if num_time is not None:
                 print("[Info] `interp_mode='spline'` is active, but a downsampled transform was already computed. "
                       "Spline interpolation will not be performed.")
                 return qtiles_stacked

            if spectrogram_shape is None:
                num_f_bins = qtiles_stacked.shape[-2]
                num_t_bins = qtiles_stacked.shape[-1]
                warnings.warn(f"`spectrogram_shape` not provided for spline mode. Returning full-resolution tiles.")
            else:
                num_f_bins, num_t_bins = spectrogram_shape
                return self.interpolate(
                    Z=qtiles_stacked, 
                    num_f_bins=num_f_bins, 
                    num_t_bins=num_t_bins,
                    polar_mode=polar_mode,
                    phase_mode=phase_mode,
                    complex_mode=complex_mode
                )
        
        return qtiles_stacked

        

    def invert_qtransform(self, qtransform, idx: Optional[int] = None, polar_mode: bool = True, energy_mode: bool =True, phase_mode: bool =True, complex_mode: bool = False, am_mode: bool = True):
        """
        Invert the Q-transform to recover the time-domain signal.

        Args:
            qtransform (torch.Tensor): 
                The spectrogram to invert. Expected shape is 
                [Batch, Channel, 2 (E/P), Frequency, Time].
            idx (Optional[int]): 
                - If an integer is provided, inverts using ONLY the specified
                  frequency tile `idx`. This is useful for analyzing a single
                  band but does not reconstruct the full signal.
                - If `None` (default), performs a full signal reconstruction by 
                  combining information from ALL frequency tiles.
        """
        # Check and format input dimensions
        
        if len(qtransform.shape) < 2:
            raise ValueError('Input must have at least 2 dimensions F,T. If not provided B,C will be added for consistency and phase will be assumed to be 0')
            
        if (not polar_mode) and complex_mode:
            
            if len(qtransform.shape) > 4:
                raise ValueError('with polar_mode= False and complex_mode=true, Input must have at most 4 dimensions B,C,F,T')
                
            while len(qtransform.shape) < 4:
                qtransform = qtransform.unsqueeze(0)
       
        else:
        
            if len(qtransform.shape) > 5:
                raise ValueError('Input must have at most 5 dimensions B,C,P,F,T')
                
            while len(qtransform.shape) < 5:
                qtransform = qtransform.unsqueeze(0)
                
            if qtransform.shape[2] > 2:
                 raise ValueError(f'Phase dimension [2] expected to be 1 or 2, found {qtransform.shape[2]} instead')


        # ---  Resample to original time dimension if necessary ---
        n_samples_original = int(self.sample_rate * self.duration)//2+1
        n_times_input = qtransform.shape[-1]
        
        if n_times_input < n_samples_original:
            print(f"Input spectrogram is downsampled (T={n_times_input}). "
                  f"Upsampling to original T={n_samples_original} before inversion...")
            
            qtransform = self.upsample(
                qtransform,
                n_samples_original,
                polar_mode=polar_mode,
                energy_mode=energy_mode,
                phase_mode=phase_mode,
                complex_mode=complex_mode,
                preserve_amplitude=True,
                demod = not am_mode
            )
        elif n_times_input > n_samples_original: 
            print(f"Input spectrogram is upsampled (T={n_times_input}). "
                  f"Downsampling to original T={n_samples_original} before inversion...")
            
            qtransform = self.downsample(
                qtransform,
                n_samples_original,
                polar_mode=polar_mode,
                energy_mode=energy_mode,
                phase_mode=phase_mode,
                complex_mode=complex_mode,
                preserve_amplitude=True,
                remod = not am_mode
            )

        # --- CASE 1: Invert using a single specified tile ---
        if idx is not None:
            print(f"Inverting using single tile index: {idx}")
            if (not polar_mode) and complex_mode:
                tile = qtransform[:, :, idx, :]
            else:
                tile = qtransform[:, :, :, idx, :]
            # Invert single tile (maximum redundancy of the Qtransform)
            fseries_scaled = self.qtile_transforms[idx].invert(tile, polar_mode, energy_mode, phase_mode, complex_mode)
            x_rec = torch.fft.irfft(fseries_scaled, norm='ortho', n=int(self.sample_rate * self.duration))
            return x_rec

        # --- CASE 2: Invert using ALL tiles for full reconstruction (VECTORIZED) ---
        else:
            
            # --- Reverse the forward process for ALL tiles at once ---
            
            # 1. Convert entire spectrogram from Energy/Phase to complex tdenerg

            if polar_mode:
                amplitude = torch.sqrt(qtransform[:, :, 0]) if energy_mode else qtransform[:, :, 0]
                        
                amplitude /= (self.sample_rate)**0.5
                
                if phase_mode:
                    phase = qtransform[:, :, 1]
                else:
                    phase = torch.zeros_like(amplitude)
                    
                tdenergy = amplitude * torch.exp(1j * phase)   
                
            elif complex_mode:
                tdenergy= qtransform/(self.sample_rate)**0.5
            else:
                tdenergy= torch.complex(qtransform[:,:,0,:,:],qtransform[:,:,1,:,:])/ (self.sample_rate)**0.5
            
            # 2. FFT all tdenergy tiles to get their windowed spectra (wenergy)
            n_rfft = (int(self.sample_rate * self.duration) // 2) + 1
            wenergy = torch.fft.fft(tdenergy, norm= 'ortho')
            #print(f'{wenergy.shape=}')
            #print(f'{n_rfft=}')

            # 3. Stack all windows to create a [F, T_freq] tensor
            all_windows = torch.stack([qt.full_window.squeeze() for qt in self.qtile_transforms])
            
            # --- Implement the Wiener Filter formula ---
    
            # 4. Numerator: Sum(wenergy * window)
            numerator = torch.sum(wenergy * all_windows[None, None, :, :], dim=2)
            
            # 5. Denominator: Sum(window^2)
            denominator = torch.sum(all_windows**2, dim=0)
        
            # 6. Reconstruct the spectrum
            fseries_reconstructed = numerator / (denominator.view(1, 1, -1))
            
            # 7. Recover the final time-domain signal
            x_rec = torch.fft.irfft(fseries_reconstructed, norm='ortho', n=int(self.sample_rate*self.duration))
            return x_rec
                

    

##########################################################################
# Multi Q Qtransform Class
##########################################################################

class QScan(torch.nn.Module):
    """
    Calculate the Q-transform of a batch of multi-channel
    time series data for a range of Q values and return
    the interpolated Q-transform with the highest energy.

    Args:
        duration:
            Length of the time series data in seconds
        sample_rate:
            Sample rate of the data in Hz
        spectrogram_shape:
            The shape of the interpolated spectrogram, specified as
            `(num_f_bins, num_t_bins)`. Because the
            frequency spacing of the Q-tiles is in log-space, the frequency
            interpolation is log-spaced as well.
        qrange:
            The lower and upper values of Q to consider. The
            actual values of Q used for the transforms are
            determined by the `get_qs` method
        frange:
            The lower and upper frequency limit to consider for
            the transform. If unspecified, default values will
            be chosen based on q, sample_rate, and duration
        mismatch:
            The maximum fractional mismatch between neighboring tiles
    """

    def __init__(
        self,
        duration: float,
        sample_rate: float,
        spectrogram_shape: Tuple[int, int],
        qrange: List[float] = [4, 64],
        frange: List[float] = [0, torch.inf],
        mismatch: float = 0.2,
        energy_mode: bool = True,
        phase_mode: bool = False
    ):
        super().__init__()
        self.qrange = qrange
        self.mismatch = mismatch
        self.qs = self.get_qs()
        self.frange = frange
        self.spectrogram_shape = spectrogram_shape
        self.energy_mode = energy_mode
        self.phase_mode = phase_mode

        # Initialize Q-transforms with configuration
        self.q_transforms = torch.nn.ModuleList([
            SingleQTransform(
                duration=duration,
                sample_rate=sample_rate,
                spectrogram_shape=spectrogram_shape,
                q=q,
                frange=self.frange.copy(),
                mismatch=self.mismatch,
                energy_mode=self.energy_mode,
                phase_mode=self.phase_mode
            ) for q in self.qs
        ])

    def get_qs(self):
        """Calculate Q values to scan"""
        deltam = 2 * (self.mismatch / 3.0) ** (1 / 2.0)
        cumum = math.log(self.qrange[1] / self.qrange[0]) / 2 ** (1 / 2.0)
        nplanes = int(max(math.ceil(cumum / deltam), 1))
        dq = cumum / nplanes
        qs = [
            self.qrange[0] * math.exp(2 ** (1 / 2.0) * dq * (i + 0.5))
            for i in range(nplanes)
        ]
        return qs

    def forward(
        self,
        X: torch.Tensor,
        fsearch_range: List[float] = None,
        norm: str = "median",
        spectrogram_shape: Optional[Tuple[int, int]] = None,
    ):
        """
        Compute the set of QTiles for each Q transform and determine which
        has the highest energy value. Interpolate and return the
        corresponding set of tiles.

        Args:
            X:
                Time series of data. Should have the duration and sample rate
                used to initialize this object. Expected input shape is
                `(B, C, T)`, where T is the number of samples, C is the number
                of channels, and B is the number of batches. If less than
                three-dimensional, axes will be added during Q-tile
                computation.
            fsearch_range:
                The lower and upper frequency values within which to search
                for the maximum energy
            norm:
                The method of interpolation used by each QTile
            spectrogram_shape:
                The shape of the interpolated spectrogram, specified as
                `(num_f_bins, num_t_bins)`. Because the
                frequency spacing of the Q-tiles is in log-space, the frequency
                interpolation is log-spaced as well. If not given, the shape
                used to initialize the transform will be used.

        Returns:
            An interpolated Q-transform for the batch of data. Output will
            have one more dimension than the input
        """
        # Compute all Q-transforms
        for transform in self.q_transforms:
            transform.compute_qtiles(X, norm)
        
        # Find Q-transform with maximum energy
        idx = torch.argmax(
            torch.Tensor([
                transform.get_max_energy(fsearch_range=fsearch_range)
                for transform in self.q_transforms
            ])
        )
        
        # Interpolate and return best transform
        spectrogram_shape = spectrogram_shape or self.spectrogram_shape
        num_f_bins, num_t_bins = spectrogram_shape
        return self.q_transforms[idx].interpolate(num_f_bins, num_t_bins, X.device)
        