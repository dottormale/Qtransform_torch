import math
from typing import List, Optional, Tuple, Union

import torch
import torch.nn.functional as F

from torch_spline_interpolation_1_0_0 import *
import numpy as np
import gc
from collections import OrderedDict

"""
All based on https://github.com/gwpy/gwpy/blob/v3.0.8/gwpy/signal/qtransform.py
The methods, names, and descriptions come almost entirely from GWpy.
This code allows the Q-transform to be performed on batches of multi-channel
input on GPU.
"""

# ============================
# External Window Functions
# ============================

def planck_taper_window_range(N: int, epsilon: float, x_min: float = -1, x_max: float = 1, device: str = 'cpu') -> torch.Tensor:
    """
    Constructs a Planck-taper window defined over an arbitrary range [x_min, x_max].
    Internally, it maps the coordinate linearly to the canonical range [-1,1] and then applies
    your provided Planck-taper formula.
    
    Args:
        N (int): Window length (number of samples).
        epsilon (float): Taper fraction (0 < epsilon < 0.5).
        x_min (float): Minimum value of the input coordinate.
        x_max (float): Maximum value of the input coordinate.
        device (str): Device.
        
    Returns:
        Tensor: A 1D tensor of shape [N] representing the Planck-taper window.
    """
    # Create coordinate x in [x_min, x_max]
    x = torch.linspace(x_min, x_max, steps=N, device=device, dtype=torch.float32)
    # Map x linearly to the canonical domain [-1,1]
    x_canonical = 2 * (x - x_min) / (x_max - x_min) - 1
    # Map to y in [0,1]
    y = (x_canonical + 1) / 2
    w = torch.ones(N, device=device, dtype=torch.float32)
    # Rising edge: 0 < y < epsilon
    mask_rise = (y > 0) & (y < epsilon)
    if mask_rise.any():
        Z_plus = 2 * epsilon * (1 / (1 + 2 * y[mask_rise] - 1) + 1 / (1 - 2 * epsilon + 2 * y[mask_rise] - 1))
        w[mask_rise] = 1.0 / (torch.exp(Z_plus) + 1.0)
    # Flat region: epsilon <= y <= 1 - epsilon
    mask_flat = (y >= epsilon) & (y <= 1 - epsilon)
    w[mask_flat] = 1.0
    # Falling edge: 1 - epsilon < y < 1
    mask_fall = (y > (1 - epsilon)) & (y < 1)
    if mask_fall.any():
        Z_minus = 2 * epsilon * (1 / (1 - 2 * y[mask_fall] + 1) + 1 / (1 - 2 * epsilon - 2 * y[mask_fall] + 1))
        w[mask_fall] = 1.0 / (torch.exp(Z_minus) + 1.0)
    # Endpoints set to 0
    w[0] = 0.0
    w[-1] = 0.0
    return w

def kaiser_window_range(L: int, beta: float = 8.6, x_min: float = -1, x_max: float = 1, device: str = 'cpu') -> torch.Tensor:
    """
    Returns a Kaiser window of length L defined over an arbitrary range [x_min, x_max].
    The window values are generated by torch.kaiser_window (which is independent of the coordinate),
    so the coordinate mapping is handled externally.
    
    Args:
        L (int): Window length.
        beta (float): Kaiser beta parameter.
        x_min (float): Minimum coordinate value.
        x_max (float): Maximum coordinate value.
        device (str): Device.
    
    Returns:
        Tensor: A 1D tensor of shape [L] representing the Kaiser window.
    """
    return torch.kaiser_window(L, beta=beta, periodic=False, device=device)

def tukey_window(window_length, alpha=0.05):
    """Generates a Tukey window."""
    if alpha < 0 or alpha > 1:
        raise ValueError("Alpha must be between 0 and 1")
    window = torch.ones(window_length)
    if alpha == 0:
        return window
    ramp = int(alpha * window_length / 2)
    if ramp == 0:
        return window
    w = torch.linspace(0, 1, ramp)
    cosine = 0.5 * (1 + torch.cos(torch.pi * (w - 1)))
    window[:ramp] = cosine
    window[-ramp:] = cosine.flip(0)
    return window

def bisquare_window(L: int, device: str = 'cpu') -> torch.Tensor:
    """
    Compute the bisquare window defined as:
      w(x) = (1 - x^2)^2, with x linearly spaced from -1 to 1.
    """
    x = torch.linspace(-1, 1, steps=L, device=device, dtype=torch.float32)
    return (1 - x**2)**2


def hann_window(L: int, device: str = "cpu") -> torch.Tensor:
    """
    Hann window.
    """
    n = torch.arange(L, device=device, dtype=torch.float32)
    w = 0.5 * (1 - torch.cos(2 * math.pi * n / (L - 1)))
    return w

                  
# ============================
# QTile Class
# ============================
class QTile(torch.nn.Module):
    """
    Compute the row of Q-tiles for a single Q value and a single
    frequency for a batch of multi-channel frequency series data.
    Invertible version with windows defined over full frequency series.
    """

    def __init__(
        self,
        q: float,
        frequency: float,
        duration: float,
        sample_rate: float,
        mismatch: float,
        logf: bool = False, # log spaced frequecies
        energy_mode: bool = True, #return energy (True) or amplitude (False) of the spectrogram
        phase_mode: bool = False, #return also the phase of the spectrogram
        window_param: Optional[Union[str, torch.Tensor]] = None, # window type ('kaiser', 'hann', 'bisqaure','tukey','planck-taper')
        tau: float = 1/2,   # parameter for planck-taper and tukey window function 
        beta: float = 8.6,  # parameter for kaiser window function 
        eps: float = 1e-5,  # small epsilon for padded values
    ):
        super().__init__()
        self.q = q
        self.frequency = frequency
        self.duration = duration
        self.sample_rate = sample_rate
        self.mismatch = mismatch
        self.logf = logf
        self.energy_mode = energy_mode
        self.phase_mode = phase_mode
        self.window_param = window_param
        self.tau = tau
        self.beta = beta
        self.eps = eps

        self.qprime = self.q / (11 ** 0.5)
        self.deltam = torch.tensor(2 * (self.mismatch / 3.0) ** 0.5)

        self.windowsize = 2 * int(self.frequency / self.qprime * self.duration) + 1
        self.pad_len = (self.duration*self.sample_rate)//2 +1 - self.windowsize
        self.pad_left = int((self.pad_len) // 2)
        self.pad_right = int((self.pad_len + 1) // 2)  

        self.register_buffer("window", self.get_window())
        self.register_buffer("full_window", self.get_full_window())
    
    def compute_window_energy(self, window):
        #Normalize by imposing Parseval condition: sum |w[t]|^2 dt = (1/N) * sum |W[f]|^2 = 1
        return torch.sum(window**2).item()/self.duration

    def get_window(self):
        #SUPPORTED WINDOWS
        
        # Bisquare (gwpy-like)
        if self.window_param is None:
            window = bisquare_window(self.windowsize)
            window[0]+=self.eps
            window[-1]+=self.eps
        
        # Custom window (user input)    
        elif isinstance(self.window_param, torch.Tensor):
            w = self.window_param.flatten()
            if w.shape[0] != self.windowsize:
                w = F.interpolate(w[None, None], size=self.windowsize, mode="linear", align_corners=False).squeeze()
                
        #Hann window
        elif self.window_param.lower() == "hann":
            window= hann_window(self.windowsize)
            window[0]+=self.eps
            window[-1]+=self.eps
            
        #Tukey window
        elif self.window_param.lower() == "tukey":
            window = tukey_window(self.windowsize, alpha=self.tau)

        #Planck-taper window
        elif self.window_param.lower() == "planck-taper":
            window = planck_taper_window_range(self.windowsize, epsilon=self.tau, x_min=-1, x_max=1)

        #Kaiser window
        elif self.window_param.lower() == "kaiser":
            window = kaiser_window_range(self.windowsize, beta=self.beta, x_min=-1, x_max=1)
            
        else:
            raise ValueError(f"Unsupported window_param: {self.window_param}")
        
        return window
    
    def get_full_window(self):
        
        # Pad window to full length with small epsilon and shift to center frequency
        full = F.pad(self.window.unsqueeze(0).unsqueeze(0), (self.pad_left, self.pad_right), value=self.eps)

        #Center window on central frequency
        self.shift = int(self.frequency * self.duration)
        full_w= torch.roll(full, shifts=self.shift- (self.windowsize // 2 +self.pad_right))
        
        #Normalize window    
        wen=self.compute_window_energy(full_w)
        norm = (wen) ** -0.5 
        full_w *= norm
        return full_w
        

    def forward(self, fseries: torch.Tensor):
        # Ensure batch dimension
        while len(fseries.shape) < 3:
            fseries = fseries[None]
            
        wenergy = fseries.to(self.full_window.device) * self.full_window
     
        tdenergy = torch.fft.ifft(wenergy, norm='ortho')
            
        tdenergy *= (self.sample_rate)**0.5 

        if self.energy_mode:
            energy = tdenergy.real**2 + tdenergy.imag**2
        else:
            energy = torch.sqrt(tdenergy.real**2 + tdenergy.imag**2)

        phase = None
        if self.phase_mode:
            phase = torch.atan2(tdenergy.imag, tdenergy.real)

        if self.phase_mode:
            return energy, phase
        return energy
        

    def invert(self, tile):
        # Extract amplitude and phase from the tile

        amplitude = torch.sqrt(tile[:, :, 0]) if self.energy_mode else tile[:, :, 0]
                
        amplitude /= (self.sample_rate)**0.5
        
        if self.phase_mode:
            phase = tile[:, :, 1]
        else:
            phase = torch.zeros_like(amplitude)
            
        tdenergy = amplitude * torch.exp(1j * phase)   
        
        # FFT back to frequency domain
        wenergy = torch.fft.fft(tdenergy, norm= 'ortho')

        # Divide by full_window to recover original fseries
        fseries = wenergy / self.full_window
        
        return fseries
        
##########################################################################
# Single Q Qtransform Class
##########################################################################

class SingleQTransform(torch.nn.Module):
    """
    Compute the Q-transform for a single Q value for a batch of
    multi-channel time series data. Input data should have
    three dimensions or fewer.

    Args:
        duration:
            Length of the time series data in seconds
        sample_rate:
            Sample rate of the data in Hz
        spectrogram_shape:
            The shape of the interpolated spectrogram, specified as
            `(num_f_bins, num_t_bins)`. Because the
            frequency spacing of the Q-tiles is in log-space, the frequency
            interpolation is log-spaced as well.
        q:
            The Q value to use for the Q transform
        frange:
            The lower and upper frequency limit to consider for
            the transform. If unspecified, default values will
            be chosen based on q, sample_rate, and duration
        mismatch:
            The maximum fractional mismatch between neighboring tiles
    """

    def __init__(
        self,
        duration: float,
        sample_rate: float,
        spectrogram_shape: Tuple[int, int],
        q: float = 12,
        frange: List[float] = [0, torch.inf],
        mismatch: float = 0.2,
        num_freq: int = 0,
        logf: bool = False,
        qtiles_mode: bool =False,
        energy_mode: bool =True,
        phase_mode: bool =False,
        free_memory: bool =False,
        unroll_phase: bool=True,
        window_param: Optional[Union[str, torch.Tensor]] = None,
        tau: float = 1/2,
        beta: float = 8.6
        
    ):
        super().__init__()
        self.q = q
        self.spectrogram_shape = spectrogram_shape
        self.sample_rate = sample_rate
        self.frange = frange
        self.duration = duration
        self.mismatch = mismatch
        self.logf= logf
        self.qtiles_mode=qtiles_mode # Allow for Qtile computation only (no interpolation). Very useful for ML applications!
        self.energy_mode=energy_mode # Allow for returning normalized amplitude instead of energy.
        self.phase_mode=phase_mode # Allow for returning also the phase of Qtransform. Very useful for ML applications!
        self.free_memory =free_memory # free allocated but unused memory after each loop. Time consumig but enables larger batches for big datasets
        self.window_param = window_param
        self.tau = tau
        self.beta = beta
        self.num_freq=num_freq
        self.unroll_phase=unroll_phase
        
        qprime = self.q / 11 ** (1 / 2.0)
        if self.frange[0] <= 0:  # set non-zero lower frequency
            self.frange[0] = 50 * self.q / (2 * torch.pi * duration)
        if math.isinf(self.frange[1]):  # set non-infinite upper frequency
            self.frange[1] = sample_rate / 2 / (1 + 1 / qprime)
        self.freqs = self.get_freqs()
        self.qtile_transforms = torch.nn.ModuleList(
            [
                QTile(
                self.q, freq, self.duration, sample_rate, self.mismatch,
                self.logf, self.energy_mode, self.phase_mode,window_param=self.window_param,tau=self.tau,beta=self.beta
            )
                for freq in self.freqs
            ]
        )
        self.qtiles = None
        self.phase_qtiles = None  

    def get_freqs(self):
        """
        Calculate the frequencies that will be used in this transform.
        For each frequency, a `QTile` is created.
        """
        minf, maxf = self.frange

        # manually set log spaced frequencies given the desired number of tiles
        if self.num_freq:
            if self.logf:
                freqs = torch.tensor(np.geomspace(minf, maxf, self.num_freq))
            else:
                freqs=torch.linspace(minf,maxf,self.num_freq)

        # use gwpy mismatch method instead
        else:
            fcum_mismatch = (
                math.log(maxf / minf) * (2 + self.q**2) ** (1 / 2.0) / 2.0
            )
            deltam = 2 * (self.mismatch / 3.0) ** (1 / 2.0)
            nfreq = int(max(1, math.ceil(fcum_mismatch / deltam)))
            fstep = fcum_mismatch / nfreq
            fstepmin = 1 / self.duration
    
            freq_base = math.exp(2 / ((2 + self.q**2) ** (1 / 2.0)) * fstep)
            freqs = torch.Tensor([freq_base ** (i + 0.5) for i in range(nfreq)])
            freqs = (minf * freqs // fstepmin) * fstepmin
        return torch.unique(freqs)

    def get_max_energy(
        self, fsearch_range: List[float] = None, dimension: str = "both"
    ):
        """
        Gets the maximum energy value among the QTiles. The maximum can
        be computed across all batches and channels, across all channels,
        across all batches, or individually for each channel/batch
        combination. This could be useful for allowing the use of different
        Q values for different channels and batches, but the slicing would
        be slow, so this isn't used yet.

        Optionally, a pair of frequency values can be specified for
        `fsearch_range` to restrict the frequencies in which the maximum
        energy value is sought.
        """
        allowed_dimensions = ["both", "neither", "channel", "batch"]
        if dimension not in allowed_dimensions:
            raise ValueError(f"Dimension must be one of {allowed_dimensions}")

        if self.qtiles is None:
            raise RuntimeError(
                "Q-tiles must first be computed with .compute_qtiles()"
            )

        if fsearch_range is not None:
            start = min(torch.argwhere(self.freqs > fsearch_range[0]))
            stop = min(torch.argwhere(self.freqs > fsearch_range[1]))
            qtiles = self.qtiles[start:stop]
        else:
            qtiles = self.qtiles

        if dimension == "both":
            return max([torch.max(qtile) for qtile in qtiles])

        max_across_t = [torch.max(qtile, dim=-1).values for qtile in qtiles]
        max_across_t = torch.stack(max_across_t, dim=-1)
        max_across_ft = torch.max(max_across_t, dim=-1).values

        if dimension == "neither":
            return max_across_ft
        if dimension == "channel":
            return torch.max(max_across_ft, dim=-2).values
        if dimension == "batch":
            return torch.max(max_across_ft, dim=-1).values


    def wrap_phase(self, phi: torch.Tensor) -> torch.Tensor:
        """
        Map phase to [-pi, pi).
        """
        two_pi = 2 * math.pi
        return (phi + math.pi) % two_pi - math.pi
    
    def unwrap_phase_time(self, phi: torch.Tensor, dim: int = -1, discont: float = math.pi) -> torch.Tensor:
        """
        Unwrap phase along the time dimension `dim` (default: last dim).
        Mirrors numpy.unwrap behavior.
    
        Args:
            phi: phase in radians (typically in [-pi, pi)).
            dim: time dimension to unwrap along (e.g., -1 if shape is [B, C, F, T]).
            discont: threshold; only jumps >= discont are corrected.
    
        Returns:
            Phase unwrapped along `dim`.
        """
        two_pi = 2 * math.pi
    
        # Differences along time
        dphi = torch.diff(phi, dim=dim)
    
        # Bring diffs into [-pi, pi)
        dphi_mod = (dphi + math.pi) % two_pi - math.pi
    
        # Match numpy.unwrap edge case: if wrapped diff == -pi but original diff > 0, add 2pi
        dphi_mod = torch.where((dphi_mod == -math.pi) & (dphi > 0), dphi_mod + two_pi, dphi_mod)
    
        # Correction to integrate
        correction = dphi_mod - dphi
    
        # Only correct large jumps
        correction = torch.where(torch.abs(dphi) >= discont, correction, torch.zeros_like(correction))
    
        # Cumulative sum of corrections and pad a leading zero
        cumsum = torch.cumsum(correction, dim=dim)
        d = dim if dim >= 0 else phi.dim() + dim
        pad_shape = list(phi.shape)
        pad_shape[d] = 1
        pad = torch.zeros(pad_shape, dtype=phi.dtype, device=phi.device)
    
        return phi + torch.cat([pad, cumsum], dim=dim)

    def compute_qtiles(self, X: torch.Tensor):
        """
        Take the FFT of the input timeseries and calculate the transform
        for each `QTile`
        """
        # Computing the FFT 
        X = torch.fft.rfft(X, norm='ortho')
        # Compute Qtiles, handling phase_mode
        if self.phase_mode:
            self.qtiles = []
            self.phase_qtiles = []
            for qtile in self.qtile_transforms:
                energy, phase = qtile(X)
                self.qtiles.append(energy)
                self.phase_qtiles.append(phase)
        else:
            self.qtiles = [qtile(X) for qtile in self.qtile_transforms]
    
    def interpolate(self, num_f_bins, num_t_bins, device, unroll_phase = True):

        if self.qtiles is None:
            raise RuntimeError(
                "Q-tiles must first be computed with .compute_qtiles()"
            )

        qtiles_stacked=torch.stack(self.qtiles,dim=2)
        if self.phase_mode:
            phase_qtiles_stacked=torch.stack(self.phase_qtiles,dim=2)

        xin = torch.linspace(0.0,self.duration, steps=qtiles_stacked.shape[-1])
        xout= torch.linspace(0.0,self.duration, steps=num_t_bins)
        
        #Inteprolate along both the time and frequency dimension using natural bicubic spline
        if self.logf:
            yout = torch.tensor(np.geomspace(
                self.frange[0],
                self.frange[1],
                num=num_f_bins,))
        else:
            yout=torch.linspace(self.frange[0], self.frange[1],num_f_bins)

        
        #define NN for 2d interpolation
        spline_interpolate_2d=SplineInterpolate2D(num_t_bins=num_t_bins, num_f_bins=num_f_bins,logf=self.logf,frange=self.frange).to(device)
        
        #interpolate Qtransform
        resampled=spline_interpolate_2d(qtiles_stacked.transpose(-1,-2),xin=xin,xout=xout,yin=self.freqs,yout=yout)    

        # Interpolate phase if required
        if self.phase_mode:   
            if unroll_phase:
                #Unroll phase
                phase_unrolled = self.unwrap_phase_time(phase_qtiles_stacked, dim=-1)  # shape [B, C, F, T]
    
                # 2D interpolation of unrolled phase
                phase_interp_unrolled = spline_interpolate_2d(
                    phase_unrolled.transpose(-1,-2), xin=xin, xout=xout,
                    yin=self.freqs.to(device), yout=yout
                )
                
                #Roll phase up
                phase_interp = self.wrap_phase(phase_interp_unrolled)
                #phase_interp = phase_interp_unrolled
            else:
                # 2D interpolation of unrolled phase
                phase_interp = spline_interpolate_2d(
                    phase_qtiles_stacked.transpose(-1,-2), xin=xin, xout=xout,
                    yin=self.freqs.to(device), yout=yout
                )
            
            return torch.stack([resampled, phase_interp], dim=2).detach().cpu()  #to(device)

        return resampled.detach().cpu()
        
    def forward(
        self,
        X: torch.Tensor,
        normalize: bool = False,
        spectrogram_shape: Optional[Tuple[int, int]] = None
#        unroll_phase: bool = True
    ):
        """
        Compute the Q-tiles and interpolate

        Args:
            X:
                Time series of data. Should have the duration and sample rate
                used to initialize this object. Expected input shape is
                `(B, C, T)`, where T is the number of samples, C is the number
                of channels, and B is the number of batches. If less than
                three-dimensional, axes will be added during Q-tile
                computation.
            norm:
                normalize input with repsect to max for nicer visualization if data is not already normalized or whitened. 
                Note the THIS BREAKS INVERTIBILITY, for VISUALIZATION ONLY!
                
            spectrogram_shape:
                The shape of the interpolated spectrogram, specified as
                `(num_f_bins, num_t_bins)`. Because the
                frequency spacing of the Q-tiles is in log-space, the frequency
                interpolation is log-spaced as well. If not given, the shape
                used to initialize the transform will be used.

        Returns:
            The interpolated Q-transform for the batch of data. Output will
            have one more dimension than the input
        """
        if normalize:
            X_norm=X.clone()
            X_norm/=torch.max(X_norm,dim=-1).values.unsqueeze(-1)
            X=X_norm
            
        self.compute_qtiles(X)
        
        # No interpolation
        if self.qtiles_mode:
            qtiles_stacked=torch.stack(self.qtiles,dim=2)
            if self.phase_mode:
                phase_qtiles_stacked=torch.stack(self.phase_qtiles,dim=2)          
                if self.unroll_phase:
                    phase_qtiles_stacked=self.unwrap_phase_time(phase_qtiles_stacked, dim=-1)
                return torch.stack([qtiles_stacked, phase_qtiles_stacked],dim=2)
            return qtiles_stacked
        
        # With inteprolation
        if spectrogram_shape is None:
            spectrogram_shape = self.spectrogram_shape
        num_f_bins, num_t_bins = spectrogram_shape
        
        interpolated = self.interpolate(num_f_bins, num_t_bins, X.device, self.unroll_phase)
        return interpolated

    def invert_qtransform(self,qtransform,idx=-1):

        #Add header dim to make sure qtransform has shape [Batch,Channel,Phase,Frequency,Time]
        while len(qtransform.shape)<5:
            qtransform=qtransform.unsqueeze(0)

        #Select one tile: qtransform is maximally redundant!
        tile=qtransform[:,:,:,idx,:]
        fseries_scaled=self.qtile_transforms[idx].invert(tile)
    
        # Recover signal
        x_rec = torch.fft.irfft(fseries_scaled, norm='ortho',n=int(self.sample_rate*self.duration))
        return x_rec
        

    

##########################################################################
# Multi Q Qtransform Class
##########################################################################

class QScan(torch.nn.Module):
    """
    Calculate the Q-transform of a batch of multi-channel
    time series data for a range of Q values and return
    the interpolated Q-transform with the highest energy.

    Args:
        duration:
            Length of the time series data in seconds
        sample_rate:
            Sample rate of the data in Hz
        spectrogram_shape:
            The shape of the interpolated spectrogram, specified as
            `(num_f_bins, num_t_bins)`. Because the
            frequency spacing of the Q-tiles is in log-space, the frequency
            interpolation is log-spaced as well.
        qrange:
            The lower and upper values of Q to consider. The
            actual values of Q used for the transforms are
            determined by the `get_qs` method
        frange:
            The lower and upper frequency limit to consider for
            the transform. If unspecified, default values will
            be chosen based on q, sample_rate, and duration
        mismatch:
            The maximum fractional mismatch between neighboring tiles
    """

    def __init__(
        self,
        duration: float,
        sample_rate: float,
        spectrogram_shape: Tuple[int, int],
        qrange: List[float] = [4, 64],
        frange: List[float] = [0, torch.inf],
        mismatch: float = 0.2,
        energy_mode: bool = True,
        phase_mode: bool = False
    ):
        super().__init__()
        self.qrange = qrange
        self.mismatch = mismatch
        self.qs = self.get_qs()
        self.frange = frange
        self.spectrogram_shape = spectrogram_shape
        self.energy_mode = energy_mode
        self.phase_mode = phase_mode

        # Initialize Q-transforms with configuration
        self.q_transforms = torch.nn.ModuleList([
            SingleQTransform(
                duration=duration,
                sample_rate=sample_rate,
                spectrogram_shape=spectrogram_shape,
                q=q,
                frange=self.frange.copy(),
                mismatch=self.mismatch,
                energy_mode=self.energy_mode,
                phase_mode=self.phase_mode
            ) for q in self.qs
        ])

    def get_qs(self):
        """Calculate Q values to scan"""
        deltam = 2 * (self.mismatch / 3.0) ** (1 / 2.0)
        cumum = math.log(self.qrange[1] / self.qrange[0]) / 2 ** (1 / 2.0)
        nplanes = int(max(math.ceil(cumum / deltam), 1))
        dq = cumum / nplanes
        qs = [
            self.qrange[0] * math.exp(2 ** (1 / 2.0) * dq * (i + 0.5))
            for i in range(nplanes)
        ]
        return qs

    def forward(
        self,
        X: torch.Tensor,
        fsearch_range: List[float] = None,
        norm: str = "median",
        spectrogram_shape: Optional[Tuple[int, int]] = None,
    ):
        """
        Compute the set of QTiles for each Q transform and determine which
        has the highest energy value. Interpolate and return the
        corresponding set of tiles.

        Args:
            X:
                Time series of data. Should have the duration and sample rate
                used to initialize this object. Expected input shape is
                `(B, C, T)`, where T is the number of samples, C is the number
                of channels, and B is the number of batches. If less than
                three-dimensional, axes will be added during Q-tile
                computation.
            fsearch_range:
                The lower and upper frequency values within which to search
                for the maximum energy
            norm:
                The method of interpolation used by each QTile
            spectrogram_shape:
                The shape of the interpolated spectrogram, specified as
                `(num_f_bins, num_t_bins)`. Because the
                frequency spacing of the Q-tiles is in log-space, the frequency
                interpolation is log-spaced as well. If not given, the shape
                used to initialize the transform will be used.

        Returns:
            An interpolated Q-transform for the batch of data. Output will
            have one more dimension than the input
        """
        # Compute all Q-transforms
        for transform in self.q_transforms:
            transform.compute_qtiles(X, norm)
        
        # Find Q-transform with maximum energy
        idx = torch.argmax(
            torch.Tensor([
                transform.get_max_energy(fsearch_range=fsearch_range)
                for transform in self.q_transforms
            ])
        )
        
        # Interpolate and return best transform
        spectrogram_shape = spectrogram_shape or self.spectrogram_shape
        num_f_bins, num_t_bins = spectrogram_shape
        return self.q_transforms[idx].interpolate(num_f_bins, num_t_bins, X.device)
        